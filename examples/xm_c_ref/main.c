// Maxmod + libgba
#include <maxmod.h>
#include <gba_base.h>
#include <gba_video.h>
#include <gba_systemcalls.h>
#include "mgba.h"
#include "agbprint.h"
#include <stdio.h>
#include <gba_interrupt.h>
#include <maxmod.h>
// Generated by mmutil -h (module IDs)
#include "soundbank.h"
// soundbank.s is assembled separately and provides `soundbank_bin` symbol

// Binary blob (MAS) produced via objcopy in Makefile
extern const unsigned char _binary_bad_apple_mas_start[];
extern const unsigned char _binary_bad_apple_mas_end[];

// Use mmInitDefault() for a canonical setup matching mmutil test ROMs
#define CHANNELS 32

// Exported by Maxmod runtime
extern mm_word mm_mixlen;
extern mm_word mmGetModuleCount(void);

int main(void) {
    // Basic GBA init + hook Maxmod vblank handler, enable mGBA logger
    irqInit();
    irqSet(IRQ_VBLANK, mmVBlank);
    irqEnable(IRQ_VBLANK);
    mgba_open();
    agb_print_init();

    REG_DISPCNT = MODE_3 | BG2_ON;

    // Ensure BIOS sound bias is enabled (raw register)
    *((volatile u16*)0x04000088) = 0x200;

    // Use real MSL soundbank embedded as binary (produced by C mmutil)
    extern const unsigned char _binary_soundbank_bin_start[];
    extern const unsigned char _binary_soundbank_bin_end[];
    const unsigned char* sb = _binary_soundbank_bin_start;
    const unsigned bank_len = (unsigned)((uintptr_t)&_binary_soundbank_bin_end - (uintptr_t)_binary_soundbank_bin_start);

    // Initialize Maxmod with defaults (match Zig logs)
    // Prune noisy prints to keep emulation fast
    mmInitDefault((mm_addr)sb, CHANNELS);
    // mgba_printf("[main] mmInitDefault() done; mm_mixlen=%u\n", (unsigned)mm_mixlen);

    // Ensure sane defaults in case the soundbank header was empty
    mmSetModuleVolume(0x400);
    mmSetEffectsVolume(0x400);
    // Do not override module tempo/pitch unless needed

    // Module count and start (match Zig logs)
    // mgba_printf("[main] module_count=%u\n", (unsigned)mmGetModuleCount());
    // mgba_printf("[main] mmStart(0, MM_PLAY_LOOP)\n");
    mmStart(MOD_BAD_APPLE, MM_PLAY_LOOP);

    // Use tempo/pitch from MAS header (don't override)

    // Simple visual heartbeat: toggle first pixel color
    volatile u16 *vid = (u16*)0x06000000;
    u16 col = 0x7FFF; // white BGR15
    unsigned frame_count = 0;
    while (1) {
        // Update Maxmod first so DMA has fresh data by VBlank
        // Frame update
        mmFrame();
        // Focused check near suspected static rows: dump first 4 mixer channels at rows 20..22
        {
            mm_word row = mmGetPositionRow();
            if (row >= 20 && row <= 22) {
                extern volatile unsigned int mm_mix_channels;
                extern unsigned int mm_ratescale;
                typedef struct { unsigned int src; unsigned int read; unsigned short freq; unsigned char vol; unsigned char pan; } mm_mixer_channel;
                mm_mixer_channel* ch = (mm_mixer_channel*)(mm_mix_channels);
                unsigned i;
                for (i = 0; i < 4; ++i) {
                    mm_mixer_channel* c = &ch[i];
                    mgba_printf("[C MIX] i=%u src=%x read=%u freq=%u vol=%u pan=%u\n", i, c->src, c->read, c->freq, c->vol, c->pan);
                }
                // Focused RATEC on channel 2
                mm_mixer_channel* c2 = &ch[2];
                if (mm_ratescale) {
                    unsigned int rate_est = ((unsigned int)c2->freq << 10) / mm_ratescale;
                    mgba_printf("[RATEC] ch=2 freq=%u ratescale=%u rate_est=%u\n", (unsigned)c2->freq, (unsigned)mm_ratescale, rate_est);
                }
            }
        }
        // Early mixer snapshot for first few frames, to compare with Zig
        if (0 && frame_count < 4) {
            extern volatile unsigned int mm_mix_channels;
            extern unsigned int mm_ratescale;
            typedef struct { unsigned int src; unsigned int read; unsigned short freq; unsigned char vol; unsigned char pan; } mm_mixer_channel;
            mm_mixer_channel* ch = (mm_mixer_channel*)(mm_mix_channels);
            unsigned i;
            for (i = 0; i < 4; ++i) {
                mm_mixer_channel* c = &ch[i];
                mgba_printf("[C MIX] i=%u src=%x read=%u freq=%u vol=%u pan=%u\n", i, c->src, c->read, c->freq, c->vol, c->pan);
                if (mm_ratescale) {
                    // Estimate pre-scale rate written by set_pitch: rate ~= (freq << 10) / mm_ratescale
                    unsigned int rate_est = ((unsigned int)c->freq << 10) / mm_ratescale;
                    mgba_printf("[C RATE] i=%u rate_est=%u ratescale=%u\n", i, rate_est, mm_ratescale);
                }
            }
        }
        // Prune per-frame prints
        VBlankIntrWait();
        *vid = col;
        col ^= 0x7FFF; // toggle
        frame_count += 1;
    }
}
