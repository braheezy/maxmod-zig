// Maxmod + libgba
#include <maxmod.h>
#include <gba_base.h>
#include <gba_video.h>
#include <gba_systemcalls.h>
#include "mgba.h"
#include "agbprint.h"
#include <stdio.h>
#include <gba_interrupt.h>
#include <maxmod.h>
// Generated by mmutil -h (module IDs)
#include "soundbank.h"
// soundbank.s is assembled separately and provides `soundbank_bin` symbol

// Binary blob (MAS) produced via objcopy in Makefile
extern const unsigned char _binary_bad_apple_mas_start[];
extern const unsigned char _binary_bad_apple_mas_end[];

// Use mmInitDefault() for a canonical setup matching mmutil test ROMs
#define CHANNELS 32

// Exported by Maxmod runtime
extern mm_word mm_mixlen;
extern mm_word mmGetModuleCount(void);

int main(void) {
    // Basic GBA init + hook Maxmod vblank handler, enable mGBA logger
    irqInit();
    irqSet(IRQ_VBLANK, mmVBlank);
    irqEnable(IRQ_VBLANK);
    mgba_open();
    agb_print_init();

    REG_DISPCNT = MODE_3 | BG2_ON;

    // Ensure BIOS sound bias is enabled (raw register)
    *((volatile u16*)0x04000088) = 0x200;

    // Use real MSL soundbank embedded as binary (produced by C mmutil)
    extern const unsigned char _binary_soundbank_bin_start[];
    extern const unsigned char _binary_soundbank_bin_end[];
    const unsigned char* sb = _binary_soundbank_bin_start;
    const unsigned bank_len = (unsigned)((uintptr_t)&_binary_soundbank_bin_end - (uintptr_t)_binary_soundbank_bin_start);

    // Initialize Maxmod with defaults (match Zig logs)
    // Prune noisy prints to keep emulation fast
    mmInitDefault((mm_addr)sb, CHANNELS);
    // mgba_printf("[main] mmInitDefault() done; mm_mixlen=%u\n", (unsigned)mm_mixlen);

    // Ensure sane defaults in case the soundbank header was empty
    mmSetModuleVolume(0x400);
    mmSetEffectsVolume(0x400);
    // Do not override module tempo/pitch unless needed

    // Module count and start (match Zig logs)
    // mgba_printf("[main] module_count=%u\n", (unsigned)mmGetModuleCount());
    // mgba_printf("[main] mmStart(0, MM_PLAY_LOOP)\n");
    mmStart(MOD_BAD_APPLE, MM_PLAY_LOOP);

    // Use tempo/pitch from MAS header (don't override)

    // Simple visual heartbeat: toggle first pixel color
    volatile u16 *vid = (u16*)0x06000000;
    u16 col = 0x7FFF; // white BGR15
    unsigned frame_count = 0;
    mm_word prev_pos = 0xFFFF;
    mm_word prev_row = 0xFFFF;
    mm_word prev_tick = 0xFFFF;
    mm_word prev_order = 0xFFFF;
    unsigned row_log_budget = 24; // bump budget to see first two patterns
    unsigned order_log_budget = 20; // track order changes
    unsigned early_mix_budget = 50; // early mixer state
    while (1) {
        // Update Maxmod first so DMA has fresh data by VBlank
        mmFrame();

        // Comprehensive telemetry: position, order, and early mixer state
        if (row_log_budget > 0 || order_log_budget > 0 || early_mix_budget > 0) {
            mm_word pos = mmGetPosition();
            mm_word row = mmGetPositionRow();
            mm_word tick = mmGetPositionTick();
            mm_word order = mmGetPosition() >> 16; // extract order from position

            // Position logging at tick==0
            if (tick == 0 && row != prev_row && row_log_budget > 0) {
                mgba_printf("[POS] pos=%u row=%u tick=%u mixlen=%u\n", (unsigned)pos, (unsigned)row, (unsigned)tick, (unsigned)mm_mixlen);
                prev_pos = pos;
                prev_row = row;
                prev_tick = tick;
                row_log_budget -= 1;
            } else {
                prev_pos = pos;
                prev_row = row;
                prev_tick = tick;
            }

            // Order change logging
            if (order != prev_order && order_log_budget > 0) {
                mgba_printf("[ORDER] order=%u pos=%u row=%u tick=%u\n", (unsigned)order, (unsigned)pos, (unsigned)row, (unsigned)tick);
                prev_order = order;
                order_log_budget -= 1;
            }

            // Early mixer state logging (first few frames)
            if (early_mix_budget > 0 && frame_count < 10) {
                mgba_printf("[EARLY] frame=%u pos=%u row=%u tick=%u order=%u\n", (unsigned)frame_count, (unsigned)pos, (unsigned)row, (unsigned)tick, (unsigned)order);
                early_mix_budget -= 1;
            }
        }

        // Toggle pixel and wait for VBlank
        *vid = col;
        col ^= 0x7FFF; // toggle
        VBlankIntrWait();
        frame_count += 1;
    }
}
