// Maxmod + libgba
#include <maxmod.h>
#include <gba_base.h>
#include <gba_video.h>
#include <gba_systemcalls.h>
#include "mgba.h"
#include "agbprint.h"
#include <stdio.h>
#include <stdarg.h>
#include <gba_interrupt.h>
#include <maxmod.h>
// Generated by mmutil -h (module IDs)
#include "soundbank.h"
// soundbank.s is assembled separately and provides `soundbank_bin` symbol

// Binary blob (MAS) produced via objcopy in Makefile
extern const unsigned char _binary_bad_apple_mas_start[];
extern const unsigned char _binary_bad_apple_mas_end[];

// Override maxmod's internal debug function at link time (enable logs)
void mm_dbgf(const char *fmt, ...) __attribute__((weak));
void mm_dbgf(const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    agb_printf(fmt, args);
    va_end(args);
}

// Use mmInitDefault() for a canonical setup matching mmutil test ROMs
#define CHANNELS 32

// Exported by Maxmod runtime
extern mm_word mm_mixlen;
extern mm_word mmGetModuleCount(void);

int main(void) {
    // Basic GBA init + hook Maxmod vblank handler, enable mGBA logger
    irqInit();
    irqSet(IRQ_VBLANK, mmVBlank);
    irqEnable(IRQ_VBLANK);
    // ALWAYS enable debug backends for comparison
    mgba_open();
    agb_print_init();

    REG_DISPCNT = MODE_3 | BG2_ON;

    // Ensure BIOS sound bias is enabled (raw register)
    *((volatile u16*)0x04000088) = 0x200;

    // Use real MSL soundbank embedded as binary (produced by C mmutil)
    extern const unsigned char _binary_soundbank_bin_start[];
    extern const unsigned char _binary_soundbank_bin_end[];
    const unsigned char* sb = _binary_soundbank_bin_start;
    const unsigned bank_len = (unsigned)((uintptr_t)&_binary_soundbank_bin_end - (uintptr_t)_binary_soundbank_bin_start);

    // Initialize Maxmod with defaults (match Zig logs)
    mgba_printf("[main] mmInitDefault() starting with bank_len=%u\n", bank_len);
    mmInitDefault((mm_addr)sb, CHANNELS);
    mgba_printf("[main] mmInitDefault() done; mm_mixlen=%u\n", (unsigned)mm_mixlen);

    // Ensure sane defaults in case the soundbank header was empty
    mmSetModuleVolume(0x400);
    mmSetEffectsVolume(0x400);
    mgba_printf("[main] volumes set: module=0x%x effects=0x%x\n", 0x400, 0x400);
    // Do not override module tempo/pitch unless needed

    // Module count and start (match Zig logs)
    mgba_printf("[main] module_count=1 (hardcoded, mmGetModuleCount not available)\n");
    mgba_printf("[main] mmStart(0, MM_PLAY_LOOP)\n");
    mmStart(MOD_BAD_APPLE, MM_PLAY_LOOP);
    mgba_printf("[main] mmStart() called\n");

    // Use tempo/pitch from MAS header (don't override)

    // Simple visual heartbeat: toggle first pixel color
    volatile u16 *vid = (u16*)0x06000000;
    u16 col = 0x7FFF; // white BGR15
    unsigned frame_count = 0;
    mm_word prev_pos = 0xFFFF;
    mm_word prev_row = 0xFFFF;
    mm_word prev_tick = 0xFFFF;
    mm_word prev_order = 0xFFFF;
    unsigned row_log_budget = 24; // bump budget to see first two patterns
    unsigned order_log_budget = 20; // track order changes
    unsigned early_mix_budget = 50; // early mixer state
    // Observe mixer channel state (symbol exported by libmm)
    typedef struct {
        void *src;
        mm_word read;
        mm_byte vol;
        mm_byte pan;
        mm_byte _pad0;
        mm_byte _pad1;
        mm_word freq;
    } mm_mixer_channel;
    extern volatile mm_mixer_channel *mm_mixchannels;

    // Track last-seen CH2 fields to print only on change
    mm_mixer_channel ch2_prev = {0};

    while (1) {
        // Update Maxmod first so DMA has fresh data by VBlank
        mgba_printf("[FRAME] frame=%u calling mmFrame()\n", frame_count);
        mmFrame();
        mgba_printf("[FRAME] frame=%u mmFrame() returned\n", frame_count);

        // ALWAYS log position data for comparison
        mm_word pos = mmGetPosition();
        mm_word row = mmGetPositionRow();
        mm_word tick = mmGetPositionTick();
        mm_word order = mmGetPosition() >> 16; // extract order from position

        mgba_printf("[POS] frame=%u pos=%u row=%u tick=%u order=%u mixlen=%u\n",
                   frame_count, (unsigned)pos, (unsigned)row, (unsigned)tick, (unsigned)order, (unsigned)mm_mixlen);

        // Track changes
        if (pos != prev_pos) {
            mgba_printf("[CHANGE] frame=%u pos: %u -> %u\n", frame_count, (unsigned)prev_pos, (unsigned)pos);
            prev_pos = pos;
        }
        if (row != prev_row) {
            mgba_printf("[CHANGE] frame=%u row: %u -> %u\n", frame_count, (unsigned)prev_row, (unsigned)row);
            prev_row = row;
        }
        if (tick != prev_tick) {
            mgba_printf("[CHANGE] frame=%u tick: %u -> %u\n", frame_count, (unsigned)prev_tick, (unsigned)tick);
            prev_tick = tick;
        }
        if (order != prev_order) {
            mgba_printf("[CHANGE] frame=%u order: %u -> %u\n", frame_count, (unsigned)prev_order, (unsigned)order);
            prev_order = order;
        }

        // Log every frame for first 100 frames
        if (frame_count < 100) {
            mgba_printf("[DETAIL] frame=%u pos=%u row=%u tick=%u order=%u\n",
                       frame_count, (unsigned)pos, (unsigned)row, (unsigned)tick, (unsigned)order);
        }

        // Mixer observation for CH2 (safe client-side logging)
        if (frame_count < 1000) {
            volatile mm_mixer_channel *ch2 = &mm_mixchannels[2];
            if (ch2->src != ch2_prev.src || ch2->read != ch2_prev.read || ch2->vol != ch2_prev.vol ||
                ch2->pan != ch2_prev.pan || ch2->freq != ch2_prev.freq) {
                mgba_printf("[CH2-MX] src=%p read=%u vol=%u pan=%u freq=%u\n",
                            ch2->src, (unsigned)ch2->read, (unsigned)ch2->vol, (unsigned)ch2->pan, (unsigned)ch2->freq);
                ch2_prev = *ch2;
            }
        }

        // Toggle pixel and wait for VBlank
        *vid = col;
        col ^= 0x7FFF; // toggle
        VBlankIntrWait();
        frame_count += 1;
    }
}
