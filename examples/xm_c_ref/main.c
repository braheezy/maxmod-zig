// Maxmod + libgba
#include <maxmod.h>
#include <gba_base.h>
#include <gba_video.h>
#include <gba_systemcalls.h>
#include "mgba.h"
#include "agbprint.h"
#include <stdio.h>
#include <stdarg.h>

static void agb_printv(const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    agb_printf(fmt, args);
    va_end(args);
}

#include <gba_interrupt.h>
#include <maxmod.h>
// Generated by mmutil -h (module IDs)
#include "soundbank.h"
// soundbank.s is assembled separately and provides `soundbank_bin` symbol

#define VERBOSE_LOG 0

// Binary blob (MAS) produced via objcopy in Makefile
extern const unsigned char _binary_bad_apple_mas_start[];
extern const unsigned char _binary_bad_apple_mas_end[];

// Override maxmod's internal debug function at link time (enable logs)
void mm_dbgf(const char *fmt, ...) __attribute__((weak));
void mm_dbgf(const char *fmt, ...) {
    if (fmt[0] == '[') {
        bool allow = false;
        switch (fmt[1]) {
            case 'B':
                // [BINDDBG]
                if (fmt[2] == 'I' && fmt[3] == 'N')
                    allow = true;
                break;
            case 'M':
                // [MIX] or [mm...]; let both through.
                allow = true;
                break;
            case 'S':
                // [SPV] or [STOPCHK]
                if (fmt[2] == 'T' && fmt[3] == 'O' && fmt[4] == 'P')
                    allow = true;
                break;
            case 'V':
                // [VOL]
                allow = (fmt[2] == 'O' && fmt[3] == 'L');
                break;
            case 'T':
                // [T0E]
                allow = (fmt[2] == '0' && fmt[3] == 'E');
                break;
            case 'U':
                // [UPD] / [UMIX]
                if (fmt[2] == 'P' && fmt[3] == 'D')
                    allow = true;
                break;
            case 'P':
                // [PANCHK]
                break;
            case 'A':
                // [DAP]
                allow = (fmt[2] == 'P');
                break;
            default:
                break;
        }
        if (!allow) return;
    }
    va_list args;
    va_start(args, fmt);
    agb_printf(fmt, args);
    va_end(args);
}

// Use mmInitDefault() for a canonical setup matching mmutil test ROMs
#define CHANNELS 32

// Exported by Maxmod runtime
extern mm_word mm_mixlen;
extern mm_word mmGetModuleCount(void);

int main(void) {
    // Basic GBA init + hook Maxmod vblank handler, enable mGBA logger
    irqInit();
    irqSet(IRQ_VBLANK, mmVBlank);
    irqEnable(IRQ_VBLANK);
    // ALWAYS enable debug backends for comparison
    mgba_open();
    agb_print_init();
    agb_printv("[STOP] value=0x%08x\n", 0x80000000);

    REG_DISPCNT = MODE_3 | BG2_ON;

    // Ensure BIOS sound bias is enabled (raw register)
    *((volatile u16*)0x04000088) = 0x200;

    // Use real MSL soundbank embedded as binary (produced by C mmutil)
    extern const unsigned char _binary_soundbank_bin_start[];
    extern const unsigned char _binary_soundbank_bin_end[];
    const unsigned char* sb = _binary_soundbank_bin_start;
    const unsigned bank_len = (unsigned)((uintptr_t)&_binary_soundbank_bin_end - (uintptr_t)_binary_soundbank_bin_start);
    agb_printv("[main] soundbank=0x%08x len=%u\n", (unsigned)(uintptr_t)sb, bank_len);

    // Initialize Maxmod with defaults (match Zig logs)
    mgba_printf("[main] mmInitDefault() starting with bank_len=%u\n", bank_len);
    mmInitDefault((mm_addr)sb, CHANNELS);
    mgba_printf("[main] mmInitDefault() done; mm_mixlen=%u\n", (unsigned)mm_mixlen);

    // Ensure sane defaults in case the soundbank header was empty
    mmSetModuleVolume(0x400);
    mmSetEffectsVolume(0x400);
    mgba_printf("[main] volumes set: module=0x%x effects=0x%x\n", 0x400, 0x400);
    // Do not override module tempo/pitch unless needed

    // Module count and start (match Zig logs)
    mgba_printf("[main] module_count=1 (hardcoded, mmGetModuleCount not available)\n");
    mgba_printf("[main] mmStart(0, MM_PLAY_LOOP)\n");
    mmStart(MOD_BAD_APPLE, MM_PLAY_LOOP);
    mgba_printf("[main] mmStart() called\n");

    // Use tempo/pitch from MAS header (don't override)

    // Simple visual heartbeat: toggle first pixel color
    volatile u16 *vid = (u16*)0x06000000;
    u16 col = 0x7FFF; // white BGR15
    unsigned frame_count = 0;
    mm_word prev_pos = 0xFFFF;
    mm_word prev_row = 0xFFFF;
    mm_word prev_tick = 0xFFFF;
    mm_word prev_order = 0xFFFF;
    unsigned row_log_budget = 24; // bump budget to see first two patterns
    unsigned order_log_budget = 20; // track order changes
    unsigned early_mix_budget = 50; // early mixer state
    // Observe mixer channel state (symbol exported by libmm)
typedef struct {
        void *src;
        mm_word read;
        mm_byte vol;
        mm_byte pan;
        mm_byte _pad0;
        mm_byte _pad1;
        mm_word freq;
    } mm_mixer_channel;
    extern volatile mm_mixer_channel *mm_mix_channels;
    extern void *mp_solution;

    extern void mmDebugFlushMixLog(void);
    // Track last-seen CH2 fields to print only on change
    mm_mixer_channel ch2_prev = {0};

    const unsigned max_frames = 90;
    while (1) {
        // Update Maxmod first so DMA has fresh data by VBlank
#if VERBOSE_LOG
        mgba_printf("[FRAME] frame=%u calling mmFrame()\n", frame_count);
#endif
        mmFrame();
#if VERBOSE_LOG
        mgba_printf("[FRAME] frame=%u mmFrame() returned\n", frame_count);
#endif

        // ALWAYS log position data for comparison
        mm_word pos = mmGetPosition();
        mm_word row = mmGetPositionRow();
        mm_word tick = mmGetPositionTick();
        mm_word order = mmGetPosition() >> 16; // extract order from position

#if VERBOSE_LOG
        mgba_printf("[POS] frame=%u pos=%u row=%u tick=%u order=%u mixlen=%u\n",
                   frame_count, (unsigned)pos, (unsigned)row, (unsigned)tick, (unsigned)order, (unsigned)mm_mixlen);
#endif

        // Track changes
#if VERBOSE_LOG
        if (pos != prev_pos) {
            mgba_printf("[CHANGE] frame=%u pos: %u -> %u\n", frame_count, (unsigned)prev_pos, (unsigned)pos);
            prev_pos = pos;
        }
        if (row != prev_row) {
            mgba_printf("[CHANGE] frame=%u row: %u -> %u\n", frame_count, (unsigned)prev_row, (unsigned)row);
            prev_row = row;
        }
        if (tick != prev_tick) {
            mgba_printf("[CHANGE] frame=%u tick: %u -> %u\n", frame_count, (unsigned)prev_tick, (unsigned)tick);
            prev_tick = tick;
        }
        if (order != prev_order) {
            mgba_printf("[CHANGE] frame=%u order: %u -> %u\n", frame_count, (unsigned)prev_order, (unsigned)order);
            prev_order = order;
        }
#endif

        // Log every frame for first 100 frames
#if VERBOSE_LOG
        if (frame_count < 100) {
            mgba_printf("[DETAIL] frame=%u pos=%u row=%u tick=%u order=%u\n",
                       frame_count, (unsigned)pos, (unsigned)row, (unsigned)tick, (unsigned)order);
        }
#endif

        // Mixer observation for CH2 (safe client-side logging)
#if VERBOSE_LOG
        if (frame_count < 1000) {
            volatile mm_mixer_channel *ch2 = &mm_mix_channels[2];
            if (ch2->src != ch2_prev.src || ch2->read != ch2_prev.read || ch2->vol != ch2_prev.vol ||
                ch2->pan != ch2_prev.pan || ch2->freq != ch2_prev.freq) {
                mgba_printf("[CH2-MX] src=%p read=%u vol=%u pan=%u freq=%u\n",
                            ch2->src, (unsigned)ch2->read, (unsigned)ch2->vol, (unsigned)ch2->pan, (unsigned)ch2->freq);
                ch2_prev = *ch2;
            }
        }
#endif

        unsigned mix_hash = 0;
        const uintptr_t bank_base = (uintptr_t)mp_solution;
        for (unsigned idx = 0; idx < 32; ++idx) {
            volatile mm_mixer_channel *chp = &mm_mix_channels[idx];
            uintptr_t src_val = (uintptr_t)chp->src;
            unsigned src_rel_hash = 0;
            if (src_val & 0x80000000u) {
                src_rel_hash = 0x80000000u;
            } else if (src_val >= bank_base) {
                src_rel_hash = (unsigned)(src_val - bank_base);
            }
            mix_hash ^= src_rel_hash;
            mix_hash ^= chp->read;
            mix_hash ^= ((unsigned)chp->vol) << (idx & 7);
            mix_hash ^= ((unsigned)chp->pan) << ((idx + 3) & 7);
            mix_hash ^= ((unsigned)chp->freq) << ((idx + 5) & 7);
        }
        agb_printv("[MXSUM] frame=%u hash=0x%08x\n", frame_count, mix_hash);
        if (frame_count <= 2) {
            for (unsigned idx = 0; idx < 32; ++idx) {
                volatile mm_mixer_channel *chp = &mm_mix_channels[idx];
                uintptr_t src_val = (uintptr_t)chp->src;
                unsigned src_rel = 0;
                if (src_val & 0x80000000u) {
                    src_rel = 0x80000000u;
                } else if (src_val >= bank_base) {
                    src_rel = (unsigned)(src_val - bank_base);
                }
                agb_printv(
                    "[MXCH] frame=%u idx=%u src=0x%08x read=0x%08x vol=%u pan=%u freq=%u\n",
                    frame_count,
                    idx,
                    src_rel,
                    (unsigned)chp->read,
                    chp->vol,
                    chp->pan,
                    (unsigned)chp->freq
                );
            }
        }

        // Toggle pixel and wait for VBlank
        *vid = col;
        col ^= 0x7FFF; // toggle
        VBlankIntrWait();
        frame_count += 1;
        if (frame_count == max_frames)
            break;
    }

    mm_dbgf("[DONE] frame_count=%u\n", frame_count);
    mmDebugFlushMixLog();
}
